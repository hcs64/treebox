// Generated by CoffeeScript 1.7.1
(function() {
  var CodeListCollection, CodeNode, CollectionAnimation, HuffmanNodeCollection, Inner, Leaf, Node, NodeAnimation, NodeCollection, NodeCollectionFromCode, ShannonFanoNode, ShannonFanoNodeCollection, WeightedNodeCollection, WeightedNodeCollectionFromSF, canvas, code_list_dropdown_menu, code_table_menu_item, collection_dropdown_menu, collections, construct_queue, context, default_node_radius, delete_menu_item, engage, huffman_collection_dropdown_menu, lerp2d, light_link_style, link_style, menu_text_invert_style, menu_text_spacing, menu_text_style, nextPos, next_shape, node_emph_style, node_style, node_text_error_style, node_text_spacing, node_text_style, pendingString, render, renderShape, setStyle, shannon_fano_dropdown_menu, shapes, sort_menu_item, tidy_menu_item, weighted_collection_dropdown_menu,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  collections = [];

  shapes = ['circle', 'square', 'hex'];

  next_shape = 0;

  construct_queue = [];

  nextPos = function() {
    return {
      x: canvas.width / 2,
      y: canvas.height / 2 + collections.length * default_node_radius * 4
    };
  };

  pendingString = '';

  engage = function(str) {
    var c, code, code_pairs, codes, collection, direct_message, letters, pair, pos, symbol, _i, _j, _k, _len, _len1, _len2, _ref;
    if (str.length === 0) {
      return;
    }
    direct_message = false;
    pos = nextPos();
    if (str[0] === ':') {
      code_pairs = str.slice(1).split(',');
      codes = {};
      for (_i = 0, _len = code_pairs.length; _i < _len; _i++) {
        pair = code_pairs[_i];
        _ref = pair.split('='), symbol = _ref[0], code = _ref[1];
        codes[symbol] = code;
      }
      if (collections.length < 1 || !(collections[collections.length - 1] instanceof CodeListCollection)) {
        collection = new CodeListCollection('diamond');
        collections.push(collection);
      } else {
        collection = collections[collections.length - 1];
        pos.y -= default_node_radius * 4;
      }
      collection.addCodes(codes, pos);
    } else {
      letters = {};
      for (_j = 0, _len1 = str.length; _j < _len1; _j++) {
        c = str[_j];
        if (c in letters) {
          direct_message = true;
          break;
        } else {
          letters[c] = frequency[c];
        }
      }
      if (direct_message) {
        letters = {};
        for (_k = 0, _len2 = str.length; _k < _len2; _k++) {
          c = str[_k];
          if (c in letters) {
            letters[c] += 1;
          } else {
            letters[c] = 1;
          }
        }
      }
      collection = new WeightedNodeCollection(shapes[next_shape]);
      next_shape = (next_shape + 1) % shapes.length;
      collection.addLeaves(letters, pos);
      collections.push(collection);
    }
  };

  node_style = {
    stroke: 'white',
    width: 1.5,
    fill: 'black'
  };

  node_emph_style = {
    stroke: 'white',
    width: 5.5,
    fill: 'black'
  };

  link_style = {
    stroke: 'white',
    width: 1.5
  };

  light_link_style = {
    stroke: 'white',
    width: .5
  };

  node_text_style = {
    fill: 'white',
    font: '16px monospace'
  };

  node_text_error_style = {
    fill: 'red',
    font: '16px monospace'
  };

  node_text_spacing = 18;

  menu_text_style = {
    fill: 'white',
    font: '16px sans'
  };

  menu_text_invert_style = {
    fill: 'black',
    font: '16px sans'
  };

  menu_text_spacing = 18;

  setStyle = function(ctx, s) {
    if (s.fill) {
      ctx.fillStyle = s.fill;
    }
    if (s.stroke) {
      ctx.strokeStyle = s.stroke;
    }
    if (s.width) {
      ctx.lineWidth = s.width;
    }
    if (s.font) {
      return ctx.font = s.font;
    }
  };

  renderShape = function(ctx, shape, radius) {
    switch (shape) {
      case 'circle':
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        break;
      case 'square':
        ctx.moveTo(-radius, -radius);
        ctx.lineTo(-radius, +radius);
        ctx.lineTo(+radius, +radius);
        ctx.lineTo(+radius, -radius);
        ctx.closePath();
        break;
      case 'diamond':
        ctx.moveTo(-radius * Math.SQRT2, 0);
        ctx.lineTo(0, +radius * Math.SQRT2);
        ctx.lineTo(+radius * Math.SQRT2, 0);
        ctx.lineTo(0, -radius * Math.SQRT2);
        ctx.closePath();
        break;
      case 'hex':
        ctx.moveTo(-radius, 0);
        ctx.lineTo(-radius / 2, -radius);
        ctx.lineTo(+radius / 2, -radius);
        ctx.lineTo(+radius, 0);
        ctx.lineTo(+radius / 2, +radius);
        ctx.lineTo(-radius / 2, +radius);
        ctx.closePath();
    }
  };

  default_node_radius = 15;

  Node = (function() {
    function Node() {}

    Node.prototype.render = function(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      setStyle(ctx, node_style);
      ctx.beginPath();
      renderShape(ctx, this.shape, this.radius);
      ctx.fill();
      ctx.stroke();
      return ctx.restore();
    };

    Node.prototype.isHit = function(pos) {
      var dx, dy;
      dx = this.x - pos.x;
      dy = this.y - pos.y;
      return dx * dx + dy * dy < this.radius * this.radius;
    };

    Node.prototype.forAll = function(fn) {
      fn(this);
    };

    Node.prototype.tryAll = function(fn) {
      return fn(this);
    };

    Node.prototype.move = function(newx, newy) {
      var dx, dy, moveFn;
      dx = newx - this.x;
      dy = newy - this.y;
      moveFn = function(node) {
        node.x += dx;
        return node.y += dy;
      };
      return this.forAll(moveFn);
    };

    Node.prototype.radius = default_node_radius;

    return Node;

  })();

  Leaf = (function(_super) {
    __extends(Leaf, _super);

    function Leaf(value, label, shape) {
      this.value = value;
      this.label = label;
      this.shape = shape;
    }

    Leaf.prototype.render = function(ctx) {
      Leaf.__super__.render.call(this, ctx);
      ctx.save();
      ctx.translate(this.x, this.y);
      setStyle(ctx, node_text_style);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if ((this.value != null) && (((this.value.length != null) && this.value.length > 0) || this.value > 0)) {
        ctx.fillText(this.value, 0, 0);
        if ((this.label != null) && this.label.length > 0) {
          ctx.fillText(this.label, 0, 2 * this.radius);
        }
      } else if ((this.label != null) && this.label.length > 0) {
        ctx.fillText(this.label, 0, 0);
      }
      return ctx.restore();
    };

    return Leaf;

  })(Node);

  Inner = (function(_super) {
    __extends(Inner, _super);

    function Inner(value, child0, child1, shape) {
      this.value = value;
      this.child0 = child0;
      this.child1 = child1;
      this.shape = shape;
    }

    Inner.prototype.render = function(ctx) {
      ctx.save();
      setStyle(ctx, link_style);
      ctx.beginPath();
      if (this.child0 != null) {
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.child0.x, this.child0.y);
      }
      if (this.child1 != null) {
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.child1.x, this.child1.y);
      }
      ctx.stroke();
      ctx.restore();
      Inner.__super__.render.call(this, ctx);
      ctx.save();
      ctx.translate(this.x, this.y);
      setStyle(ctx, node_text_style);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (this.value != null) {
        ctx.fillText(this.value, 0, 0);
      }
      ctx.restore();
      if (this.child0 != null) {
        this.child0.render(ctx);
      }
      if (this.child1 != null) {
        return this.child1.render(ctx);
      }
    };

    Inner.prototype.forAll = function(fn) {
      if (this.child0 != null) {
        this.child0.forAll(fn);
      }
      if (this.child1 != null) {
        this.child1.forAll(fn);
      }
      return fn(this);
    };

    Inner.prototype.tryAll = function(fn) {
      var result;
      if (this.child0) {
        result = this.child0.tryAll(fn);
        if (result != null) {
          return result;
        }
      }
      if (this.child1) {
        result = this.child1.tryAll(fn);
        if (result != null) {
          return result;
        }
      }
      return fn(this);
    };

    return Inner;

  })(Node);

  ShannonFanoNode = (function(_super) {
    __extends(ShannonFanoNode, _super);

    function ShannonFanoNode(contains, shape, default_bbox, label) {
      this.contains = contains;
      this.shape = shape;
      this.default_bbox = default_bbox;
      this.label = label;
      this.len_x = this.default_bbox.len.x;
      this.len_y = this.default_bbox.len.y;
      this.x = this.default_bbox.min.x + this.len_x / 2;
      this.y = this.default_bbox.min.y + this.len_y / 2;
      this.update();
    }

    ShannonFanoNode.prototype.render = function(ctx) {
      var n, _i, _len, _ref, _results;
      ctx.save();
      setStyle(ctx, node_style);
      ctx.translate(this.x, this.y);
      ctx.save();
      ctx.scale(this.len_x, this.len_y);
      ctx.beginPath();
      renderShape(ctx, this.shape, .5);
      ctx.scale(1 / this.len_x, 1 / this.len_y);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      setStyle(ctx, node_text_style);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(this.value, 0, -this.len_y / 2);
      ctx.restore();
      _ref = this.contains;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(n.render(ctx));
      }
      return _results;
    };

    ShannonFanoNode.prototype.update = function() {
      var maxx, maxy, minx, miny, n, _i, _len, _ref;
      this.value = 0;
      if (this.contains.length > 0) {
        minx = maxx = this.contains[0].x;
        miny = maxy = this.contains[0].y;
        this.value = this.contains[0].value;
        _ref = this.contains.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          this.value += n.value;
          minx = Math.min(minx, n.x);
          maxx = Math.max(maxx, n.x);
          miny = Math.min(miny, n.y);
          maxy = Math.max(maxy, n.y);
        }
        this.x = (maxx + minx) / 2;
        this.y = (maxy + miny) / 2;
        this.len_x = maxx - minx + default_node_radius * 6;
        return this.len_y = maxy - miny + default_node_radius * 6;
      } else {
        this.len_x = this.default_bbox.len.x;
        return this.len_y = this.default_bbox.len.y;
      }
    };

    ShannonFanoNode.prototype.getSize = function() {
      return {
        width: this.len_x,
        height: this.len_y
      };
    };

    ShannonFanoNode.prototype.addNode = function(node) {
      this.contains.push(node);
      node.parent = this;
      return this.update();
    };

    ShannonFanoNode.prototype.removeNode = function(remove_node) {
      var n;
      this.contains = (function() {
        var _i, _len, _ref, _results;
        _ref = this.contains;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (n !== remove_node) {
            _results.push(n);
          }
        }
        return _results;
      }).call(this);
      remove_node.parent = null;
      return this.update();
    };

    ShannonFanoNode.prototype.isHit = function(pos) {
      return (this.x - pos.x <= this.len_x / 2 && pos.x - this.x < this.len_x / 2) && (this.y - pos.y <= this.len_y / 2 && pos.y - this.y < this.len_y / 2);
    };

    ShannonFanoNode.prototype.forAll = function(fn) {
      var n, _i, _len, _ref;
      _ref = this.contains;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.forAll(fn);
      }
      return fn(this);
    };

    ShannonFanoNode.prototype.tryAll = function(fn) {
      var n, result, _i, _len, _ref;
      _ref = this.contains;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        result = n.tryAll(fn);
        if (result != null) {
          return result;
        }
      }
      return fn(this);
    };

    return ShannonFanoNode;

  })(Node);

  CodeNode = (function(_super) {
    __extends(CodeNode, _super);

    function CodeNode(symbol, code) {
      this.symbol = symbol;
      this.code = code;
      this.error = null;
      this.width = this.radius;
    }

    CodeNode.prototype.render = function(ctx) {
      var msg;
      ctx.save();
      if (this.error != null) {
        setStyle(ctx, node_text_error_style);
      } else {
        setStyle(ctx, node_text_style);
      }
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      msg = "" + this.symbol + " = " + this.code;
      ctx.fillText(msg, this.x, this.y);
      this.width = ctx.measureText(msg).width;
      return ctx.restore();
    };

    CodeNode.prototype.isHit = function(pos) {
      var dx, dy;
      dx = pos.x - this.x;
      dy = pos.y - this.y;
      return dy > 0 && dy < node_text_spacing && dx > 0 && dx < this.width;
    };

    return CodeNode;

  })(Node);

  tidy_menu_item = {
    name: 'tidy',
    action: function(c, t) {
      var n, _i, _len, _ref, _results;
      console.log('tidy trees');
      _ref = c.nodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(c.tidy(n, {
          x: n.x,
          y: n.y
        }));
      }
      return _results;
    }
  };

  code_table_menu_item = {
    name: 'convert to code table',
    action: function(c, t) {
      console.log('convert to code table');
      if (c.nodes.length !== 1) {
        return console.log('only can convert a single tree');
      } else {
        return c.convertToCode();
      }
    }
  };

  delete_menu_item = {
    name: 'delete',
    action: function(c, t) {
      console.log('delete');
      return c.delete_flag = true;
    }
  };

  sort_menu_item = {
    name: 'sort by weight',
    action: function(c, t) {
      console.log('sort by weight');
      return c.addAnimations(c.sortNodes((function(n1, n2) {
        return n2.value - n1.value;
      }), t));
    }
  };

  collection_dropdown_menu = [tidy_menu_item, code_table_menu_item, delete_menu_item];

  weighted_collection_dropdown_menu = [
    tidy_menu_item, code_table_menu_item, {
      name: 'Shannon-Fano',
      action: function(c, t) {
        console.log('Shannon-Fano');
        return c.reconstruct_as = ShannonFanoNodeCollection;
      }
    }, {
      name: 'Huffman',
      action: function(c, t) {
        console.log('Huffman');
        return c.reconstruct_as = HuffmanNodeCollection;
      }
    }, {
      name: 'average message size',
      action: function(c, t) {
        return console.log('compute average message size');
      }
    }, {
      name: 'remove values',
      action: function(c, t) {
        console.log('remove values');
        return c.reconstruct_as = NodeCollection;
      }
    }, delete_menu_item
  ];

  huffman_collection_dropdown_menu = [
    sort_menu_item, tidy_menu_item, {
      name: 'automatic Huffman step',
      action: function(c, t) {
        return console.log('automatic Huffman step');
      }
    }, {
      name: 'finish Huffman',
      action: function(c, t) {
        console.log('finish Huffman');
        return c.reconstruct_as = WeightedNodeCollection;
      }
    }, delete_menu_item
  ];

  shannon_fano_dropdown_menu = [
    tidy_menu_item, {
      name: 'automatic Shannon-Fano step',
      action: function(c, t) {
        return console.log('automatic Shannon-Fano step');
      }
    }, {
      name: 'finish Shannon-Fano',
      action: function(c, t) {
        var checkCompletion;
        console.log('finish Shannon-Fano');
        checkCompletion = function(node) {
          var result;
          if ((node.contains != null) && node.contains.length !== 1) {
            return false;
          }
          result = true;
          if (node.child0 != null) {
            result = result && checkCompletion(node.child0) && checkCompletion(node.child1);
          }
          return result;
        };
        if (checkCompletion(c.nodes[0])) {
          return c.reconstruct_as = WeightedNodeCollectionFromSF;
        } else {
          return console.log('won\'t finish S-F, incomplete');
        }
      }
    }, delete_menu_item
  ];

  code_list_dropdown_menu = [
    {
      name: 'convert to tree',
      action: function(c, t) {
        console.log('convert to tree');
        return c.convertToTree();
      }
    }, delete_menu_item
  ];

  NodeCollection = (function() {
    function NodeCollection(shape) {
      this.shape = shape;
      this.nodes = [];
      this.animations = [];
    }

    NodeCollection.prototype.takeNodesFrom = function(nc) {
      var n, rvFn, _i, _len, _ref, _results;
      this.nodes = nc.nodes;
      rvFn = function(node) {
        if (node.value != null) {
          node.saved_value = node.value;
        }
        return delete node.value;
      };
      _ref = this.nodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(n.forAll(rvFn));
      }
      return _results;
    };

    NodeCollection.prototype.render = function(ctx, idx, t) {
      var n, _i, _len, _ref;
      if (this.animations.length > 0) {
        this.animations[0].setPositions(t);
        if (this.animations[0].isFinished(t)) {
          this.animations = this.animations.slice(1);
        }
      }
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        ctx.save();
        n.render(ctx);
        ctx.restore();
      }
      ctx.save();
      ctx.translate(default_node_radius * 2, default_node_radius * (2 + 3 * idx));
      setStyle(ctx, node_style);
      ctx.beginPath();
      renderShape(ctx, this.shape, default_node_radius);
      if (this.dropdown_menu != null) {
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
      } else {
        ctx.stroke();
      }
      ctx.restore();
    };

    NodeCollection.prototype.render_overlay = function(ctx, idx) {
      var i, measure, option, _i, _len, _ref;
      if (this.dropdown_menu != null) {
        ctx.save();
        ctx.textAlign = 'start';
        ctx.textBaseline = 'top';
        _ref = this.dropdown_menu.options;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          option = _ref[i];
          setStyle(ctx, menu_text_style);
          measure = ctx.measureText(option.name);
          ctx.fillStyle = this.dropdown_menu.selected === i ? 'white' : 'black';
          ctx.fillRect(this.dropdown_menu.pos.x, this.dropdown_menu.pos.y + menu_text_spacing * (i + 1), measure.width, menu_text_spacing);
          setStyle(ctx, this.dropdown_menu.selected === i ? menu_text_invert_style : menu_text_style);
          ctx.fillText(option.name, this.dropdown_menu.pos.x, this.dropdown_menu.pos.y + menu_text_spacing * (i + 1));
        }
        ctx.restore();
      }
    };

    NodeCollection.prototype.mousedown = function(pos, idx, t) {
      var hit, n, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        hit = n.tryAll(function(node) {
          if (node.isHit(pos)) {
            return node;
          } else {
            return null;
          }
        });
        if (hit != null) {
          this.selected = {
            node: hit,
            ox: hit.x,
            oy: hit.y,
            mx: pos.x,
            my: pos.y,
            t: t
          };
          return true;
        }
      }
      if (this.isHandleHit(pos, idx)) {
        this.dropdown_menu = {
          pos: pos,
          options: this.collection_dropdown_menu,
          selected: -1
        };
      }
      return false;
    };

    NodeCollection.prototype.isHandleHit = function(pos, idx) {
      var dx, dy;
      dx = pos.x - default_node_radius * 2;
      dy = pos.y - default_node_radius * (2 + 3 * idx);
      return dx * dx + dy * dy < default_node_radius * default_node_radius;
    };

    NodeCollection.prototype.collection_dropdown_menu = collection_dropdown_menu;

    NodeCollection.prototype.mousemove = function(pos) {
      var i, newx, newy, option, s, _i, _len, _ref;
      if (this.dropdown_menu != null) {
        this.dropdown_menu.selected = -1;
        _ref = this.dropdown_menu.options;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          option = _ref[i];
          if (pos.x > this.dropdown_menu.pos.x && pos.y >= this.dropdown_menu.pos.y + menu_text_spacing * (i + 1) && pos.y < this.dropdown_menu.pos.y + menu_text_spacing * (i + 2)) {
            this.dropdown_menu.selected = i;
          }
        }
        return;
      }
      if (this.selected != null) {
        s = this.selected;
        newx = pos.x - s.mx + s.ox;
        newy = pos.y - s.my + s.oy;
        s.node.move(newx, newy);
      }
    };

    NodeCollection.prototype.mouseup = function(pos, t) {
      var mdx, mdy, newcollection;
      if (this.dropdown_menu != null) {
        if (this.dropdown_menu.selected >= 0) {
          this.dropdown_menu.options[this.dropdown_menu.selected].action(this, t);
        }
        this.dropdown_menu = null;
        if (this.delete_flag) {
          return null;
        } else if (this.reconstruct_as != null) {
          newcollection = new this.reconstruct_as(this.shape);
          newcollection.takeNodesFrom(this);
          delete this.reconstruct_as;
          return newcollection;
        } else {
          return this;
        }
      }
      if (this.selected != null) {
        if (t - this.selected.t < .2) {
          mdx = pos.x - this.selected.mx;
          mdy = pos.y - this.selected.my;
          if (mdx * mdx + mdy * mdy < 10 * 10) {
            this.clickend(pos, t);
          }
        }
      }
      this.selected = null;
      return this;
    };

    NodeCollection.prototype.clickend = function() {};

    NodeCollection.prototype.makeLineupAnim = function(yoffset, duration, t) {
      var anims, midpointy, n, _i, _len, _ref;
      midpointy = 0;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        midpointy += n.y;
      }
      midpointy /= this.nodes.length;
      anims = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = this.nodes;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          _results.push(new NodeAnimation(n, {
            x: n.x,
            y: midpointy + yoffset
          }, duration));
        }
        return _results;
      }).call(this);
      return new CollectionAnimation(anims, t);
    };

    NodeCollection.prototype.makeMove1Anim = function(node, dest, duration, t) {
      return new CollectionAnimation([new NodeAnimation(node, dest, duration)], t);
    };

    NodeCollection.prototype.addAnimations = function(anims) {
      return this.animations = this.animations.concat(anims);
    };

    NodeCollection.prototype.tidy = function(tree, tree_pos) {
      var anims, c, calcBounds, duration, i, moved_nodes, new_positions, newpos, own_height, p, pidx, pos, ppos, rel_pos, rp, _i, _ref;
      rel_pos = [];
      calcBounds = function(node) {
        var c, cb, children, children_max_height, children_width, height, idx, own_height, own_width, width, x, _i, _j, _len, _len1, _ref;
        if (node.getSize != null) {
          _ref = node.getSize(), own_width = _ref.width, own_height = _ref.height;
        } else {
          own_width = node.radius * 2;
          own_height = node.radius * 2;
        }
        width = own_width;
        height = own_height;
        children = [];
        if (node.child0 != null) {
          children.push(node.child0);
        } else if (node.child1 != null) {
          children.push({
            radius: default_node_radius,
            dummy: true
          });
        }
        if (node.child1 != null) {
          children.push(node.child1);
        } else if (node.child0 != null) {
          children.push({
            radius: default_node_radius,
            dummy: true
          });
        }
        if (children.length > 0) {
          children_width = 0;
          children_max_height = 0;
          for (idx = _i = 0, _len = children.length; _i < _len; idx = ++_i) {
            c = children[idx];
            cb = calcBounds(c);
            children_width += cb.width;
            children_max_height = Math.max(children_max_height, cb.height);
          }
          width = Math.max(own_width, children_width);
          height = Math.max(own_height, children_max_height + 2 * default_node_radius);
          x = -width / 2;
          for (idx = _j = 0, _len1 = children.length; _j < _len1; idx = ++_j) {
            c = children[idx];
            rel_pos.push({
              parent: node,
              child: c,
              pos: {
                x: x + width / children.length / 2,
                y: default_node_radius * 3
              }
            });
            x += width / children.length;
          }
        }
        return {
          width: width + default_node_radius,
          height: height + default_node_radius
        };
      };
      calcBounds(tree);
      duration = .1;
      anims = [new NodeAnimation(tree, tree_pos, duration)];
      moved_nodes = [tree];
      new_positions = [tree_pos];
      for (i = _i = _ref = rel_pos.length - 1; _i >= 0; i = _i += -1) {
        rp = rel_pos[i];
        c = rp.child;
        p = rp.parent;
        pos = rp.pos;
        if (c.dummy) {
          continue;
        }
        pidx = moved_nodes.indexOf(p);
        ppos = new_positions[pidx];
        if (c.getSize != null) {
          own_height = c.getSize().height;
        } else {
          own_height = c.radius * 2;
        }
        newpos = {
          x: ppos.x + pos.x,
          y: ppos.y + pos.y + own_height / 2
        };
        new_positions.push(newpos);
        moved_nodes.push(c);
        anims.push(new NodeAnimation(c, newpos, duration));
      }
      return this.addAnimations([new CollectionAnimation(anims, -1)]);
    };

    NodeCollection.prototype.convertToCode = function() {
      var codes, walkTree;
      codes = {};
      walkTree = function(node, base) {
        if (base == null) {
          base = '';
        }
        if (node.child0 != null) {
          walkTree(node.child0, base + '0');
        }
        if (node.child1 != null) {
          walkTree(node.child1, base + '1');
        }
        if ((node.label != null) && node.label.length > 0) {
          return codes[node.label] = base;
        }
      };
      walkTree(this.nodes[0]);
      return construct_queue.push({
        "const": CodeListCollection,
        add_from: codes
      });
    };

    return NodeCollection;

  })();

  WeightedNodeCollection = (function(_super) {
    __extends(WeightedNodeCollection, _super);

    function WeightedNodeCollection(shape) {
      WeightedNodeCollection.__super__.constructor.call(this, shape);
    }

    WeightedNodeCollection.prototype.takeNodesFrom = function(nc) {
      return this.nodes = nc.nodes;
    };

    WeightedNodeCollection.prototype.collection_dropdown_menu = weighted_collection_dropdown_menu;

    WeightedNodeCollection.prototype.addLeaves = function(dict, pos) {
      var i, label, leaf, length, value, _results;
      length = 0;
      for (value in dict) {
        length += 1;
      }
      i = 0;
      _results = [];
      for (label in dict) {
        value = dict[label];
        leaf = new Leaf(value, label, this.shape);
        this.nodes.push(leaf);
        leaf.x = pos.x + (i / length - .5) * 3 * leaf.radius * length;
        leaf.y = pos.y;
        _results.push(i += 1);
      }
      return _results;
    };

    WeightedNodeCollection.prototype.sortNodes = function(compare, t) {
      var anims, desty, i, max, maxi, maxx, minx, n, newnodes, oldnodes, spacing, totaly, width, _i, _j, _len, _len1, _ref, _ref1;
      if (this.nodes.length === 1) {
        return [];
      }
      anims = [];
      anims.push(this.makeLineupAnim(default_node_radius * 2, .1, t));
      minx = this.nodes[0].x;
      maxx = this.nodes[0].x;
      totaly = this.nodes[0].y;
      _ref = this.nodes.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        totaly += n.y;
        minx = Math.min(n.x, minx);
        maxx = Math.max(n.x, maxx);
      }
      desty = totaly / this.nodes.length;
      width = Math.max(maxx - minx, this.nodes.length * default_node_radius * 2);
      spacing = width / (this.nodes.length - 1);
      oldnodes = this.nodes.slice(0);
      newnodes = [];
      while (oldnodes.length > 0) {
        max = oldnodes[0];
        maxi = 0;
        _ref1 = oldnodes.slice(1);
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          n = _ref1[i];
          if (compare(n, max) > 0) {
            max = n;
            maxi = i + 1;
          }
        }
        oldnodes = (function() {
          var _k, _len2, _results;
          _results = [];
          for (i = _k = 0, _len2 = oldnodes.length; _k < _len2; i = ++_k) {
            n = oldnodes[i];
            if (i !== maxi) {
              _results.push(n);
            }
          }
          return _results;
        })();
        anims.push(this.makeMove1Anim(max, {
          x: minx + newnodes.length * spacing,
          y: desty
        }, .1, -1));
        newnodes.push(max);
      }
      this.nodes = newnodes;
      return anims;
    };

    return WeightedNodeCollection;

  })(NodeCollection);

  HuffmanNodeCollection = (function(_super) {
    __extends(HuffmanNodeCollection, _super);

    function HuffmanNodeCollection(shape) {
      HuffmanNodeCollection.__super__.constructor.call(this, shape);
    }

    HuffmanNodeCollection.prototype.mousedown = function(pos, idx, t) {
      var n, _i, _len, _ref;
      if (this.merging != null) {
        _ref = this.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (n.isHit(pos)) {
            if (n !== this.merging.node) {
              if (this.merging.node.x < n.x) {
                this.mergeNodes(this.merging.node, n);
                this.merging = null;
                return true;
              } else {
                console.log('abort merge from right to left');
              }
            }
          }
        }
        this.merging = null;
      }
      return HuffmanNodeCollection.__super__.mousedown.call(this, pos, idx, t);
    };

    HuffmanNodeCollection.prototype.mousemove = function(pos) {
      HuffmanNodeCollection.__super__.mousemove.call(this, pos);
      if (this.merging != null) {
        this.merging.x = pos.x;
        this.merging.y = pos.y;
      }
    };

    HuffmanNodeCollection.prototype.collection_dropdown_menu = huffman_collection_dropdown_menu;

    HuffmanNodeCollection.prototype.mergeNodes = function(node0, node1) {
      var n, newnode;
      this.nodes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.nodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (n !== node0 && n !== node1) {
            _results.push(n);
          }
        }
        return _results;
      }).call(this);
      newnode = new Inner(node0.value + node1.value, node0, node1, this.shape);
      newnode.x = (node0.x + node1.x) / 2;
      newnode.y = Math.min(node0.y, node1.y) - Math.abs(node0.x - node1.x);
      return this.nodes.push(newnode);
    };

    HuffmanNodeCollection.prototype.clickend = function(pos, t) {
      var _ref;
      if (_ref = this.selected.node, __indexOf.call(this.nodes, _ref) >= 0) {
        return this.merging = {
          node: this.selected.node,
          x: pos.x,
          y: pos.y
        };
      } else {
        return HuffmanNodeCollection.__super__.clickend.call(this, pos, t);
      }
    };

    HuffmanNodeCollection.prototype.render = function(ctx, idx, t) {
      if (this.merging != null) {
        ctx.save();
        setStyle(ctx, light_link_style);
        ctx.beginPath();
        ctx.moveTo(this.merging.node.x, this.merging.node.y);
        ctx.lineTo(this.merging.x, this.merging.y);
        ctx.stroke();
        ctx.restore();
      }
      return HuffmanNodeCollection.__super__.render.call(this, ctx, idx, t);
    };

    return HuffmanNodeCollection;

  })(WeightedNodeCollection);

  ShannonFanoNodeCollection = (function(_super) {
    __extends(ShannonFanoNodeCollection, _super);

    function ShannonFanoNodeCollection(shape) {
      ShannonFanoNodeCollection.__super__.constructor.call(this, shape);
    }

    ShannonFanoNodeCollection.prototype.defaultBBoxAt = function(pos) {
      return {
        min: {
          x: pos.x - default_node_radius * 2,
          y: pos.y - default_node_radius * 2
        },
        len: {
          x: default_node_radius * 4,
          y: default_node_radius * 2
        }
      };
    };

    ShannonFanoNodeCollection.prototype.takeNodesFrom = function(nc) {
      var anims;
      anims = nc.sortNodes((function(n1, n2) {
        return n2.value - n1.value;
      }), 1);
      this.addAnimations(anims);
      return this.nodes = [
        new ShannonFanoNode(nc.nodes, this.shape, this.defaultBBoxAt({
          x: 100,
          y: 100
        }), "")
      ];
    };

    ShannonFanoNodeCollection.prototype.render = function(ctx, idx, t) {
      if (this.splitting != null) {
        ctx.save();
        setStyle(ctx, light_link_style);
        ctx.beginPath();
        ctx.moveTo(this.splitting.node.x, this.splitting.node.y);
        ctx.lineTo(this.splitting.pos0.x, this.splitting.pos0.y);
        ctx.moveTo(this.splitting.node.x, this.splitting.node.y);
        ctx.lineTo(this.splitting.pos1.x, this.splitting.pos1.y);
        ctx.stroke();
        ctx.restore();
      }
      return ShannonFanoNodeCollection.__super__.render.call(this, ctx, idx, t);
    };

    ShannonFanoNodeCollection.prototype.collection_dropdown_menu = shannon_fano_dropdown_menu;

    ShannonFanoNodeCollection.prototype.mousedown = function(pos, idx, t) {
      if (ShannonFanoNodeCollection.__super__.mousedown.call(this, pos, idx, t)) {
        return true;
      }
      if (this.splitting != null) {
        this.splitNode(this.splitting.node, this.splitting.pos0, this.splitting.pos1);
        this.splitting = null;
        return true;
      }
    };

    ShannonFanoNodeCollection.prototype.mousemove = function(pos) {
      ShannonFanoNodeCollection.__super__.mousemove.call(this, pos);
      if (this.splitting != null) {
        this.splitting.pos0 = {
          x: pos.x,
          y: pos.y
        };
        this.splitting.pos1 = {
          x: 2 * this.splitting.node.x - pos.x,
          y: pos.y
        };
      }
    };

    ShannonFanoNodeCollection.prototype.mouseup = function(pos, t) {
      var n, other_node, return_value, this_node, updateFn, _i, _len, _ref;
      if ((this.selected != null) && (this.selected.node.parent != null) && !this.selected.node.parent.isHit(pos)) {
        this_node = this.selected.node.parent;
        other_node = this_node.sibling;
        this_node.removeNode(this.selected.node);
        other_node.addNode(this.selected.node);
      }
      return_value = ShannonFanoNodeCollection.__super__.mouseup.call(this, pos, t);
      updateFn = function(node) {
        if (node.update != null) {
          return node.update();
        }
      };
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.forAll(updateFn);
      }
      return return_value;
    };

    ShannonFanoNodeCollection.prototype.clickend = function(pos, t) {
      if (this.splitting) {
        return this.splitting = null;
      } else if ((this.selected.node.contains != null) && this.selected.node.contains.length > 1) {
        return this.splitting = {
          node: this.selected.node,
          pos0: pos,
          pos1: pos
        };
      }
    };

    ShannonFanoNodeCollection.prototype.splitNode = function(node, pos0, pos1) {
      var n, new0, new1, newnode, _i, _len, _ref;
      new0 = new ShannonFanoNode(node.contains, this.shape, this.defaultBBoxAt(pos0), 0);
      new1 = new ShannonFanoNode([], this.shape, this.defaultBBoxAt(pos1), 1);
      new0.sibling = new1;
      new1.sibling = new0;
      _ref = node.contains;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.parent = new0;
      }
      newnode = new Inner(node.value, new0, new1, this.shape);
      new1.move(node.x, node.y);
      this.addAnimations([this.makeMoveContainsAnim([new0, new1], [pos0, pos1], .2, -1)]);
      newnode.x = node.x;
      newnode.y = node.y;
      return this.replaceNode(node, newnode);
    };

    ShannonFanoNodeCollection.prototype.replaceNode = function(oldnode, newnode) {
      var n, replaceFn, _i, _len, _ref;
      replaceFn = function(node) {
        if (node.child0 === oldnode) {
          node.child0 = newnode;
        }
        if (node.child1 === oldnode) {
          return node.child1 = newnode;
        }
      };
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.forAll(replaceFn);
      }
      this.nodes = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = this.nodes;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          if (n === oldnode) {
            _results.push(newnode);
          } else {
            _results.push(n);
          }
        }
        return _results;
      }).call(this);
    };

    ShannonFanoNodeCollection.prototype.makeMoveContainsAnim = function(nodes, dests, duration, t) {
      var anims, dest, dx, dy, idx, n, node, _i, _j, _len, _len1, _ref;
      anims = [];
      for (idx = _i = 0, _len = nodes.length; _i < _len; idx = ++_i) {
        node = nodes[idx];
        dest = dests[idx];
        dx = dest.x - node.x;
        dy = dest.y - node.y;
        anims.push(new NodeAnimation(node, dest, duration));
        _ref = node.contains;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          n = _ref[_j];
          anims.push(new NodeAnimation(n, {
            x: n.x + dx,
            y: n.y + dy
          }, duration));
        }
      }
      return new CollectionAnimation(anims, t);
    };

    return ShannonFanoNodeCollection;

  })(WeightedNodeCollection);

  WeightedNodeCollectionFromSF = (function(_super) {
    __extends(WeightedNodeCollectionFromSF, _super);

    function WeightedNodeCollectionFromSF(shape) {
      WeightedNodeCollectionFromSF.__super__.constructor.call(this, shape);
    }

    WeightedNodeCollectionFromSF.prototype.takeNodesFrom = function(sf) {
      var rebuildFromSF;
      rebuildFromSF = (function(_this) {
        return function(node) {
          var n, nold;
          if (node.contains != null) {
            nold = node.contains[0];
            n = new Leaf(nold.value, nold.label, _this.shape);
          } else if (node.child0 != null) {
            n = new Inner(node.value, rebuildFromSF(node.child0), rebuildFromSF(node.child1), _this.shape);
          } else {
            throw 'hit unhandled node';
            return null;
          }
          n.x = node.x;
          n.y = node.y;
          return n;
        };
      })(this);
      return this.nodes = [rebuildFromSF(sf.nodes[0])];
    };

    return WeightedNodeCollectionFromSF;

  })(WeightedNodeCollection);

  CodeListCollection = (function(_super) {
    __extends(CodeListCollection, _super);

    function CodeListCollection(shape) {
      CodeListCollection.__super__.constructor.call(this, shape);
      this.codes = {};
      this.errors = false;
    }

    CodeListCollection.prototype.collection_dropdown_menu = code_list_dropdown_menu;

    CodeListCollection.prototype.addCodes = function(codes, pos) {
      var code, symbol;
      for (symbol in codes) {
        code = codes[symbol];
        this.addCode(symbol, code);
      }
      return this.arrangeCodes(pos.x, pos.y);
    };

    CodeListCollection.prototype.setNodes = function(codes, pos) {
      return this.addCodes(codes, pos);
    };

    CodeListCollection.prototype.addCode = function(symbol, code) {
      var n, newval, oldval;
      oldval = this.codes[symbol];
      newval = new CodeNode(symbol, code);
      if (oldval != null) {
        this.nodes = (function() {
          var _i, _len, _ref, _results;
          _ref = this.nodes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            if (n === oldval) {
              _results.push(newval);
            } else {
              _results.push(n);
            }
          }
          return _results;
        }).call(this);
      } else {
        this.nodes.push(newval);
      }
      this.codes[symbol] = newval;
      return this.checkForErrors();
    };

    CodeListCollection.prototype.checkForErrors = function() {
      var codeobj, codeobj2, err, n, ok, symbol, symbol2, _i, _len, _ref, _ref1, _ref2;
      this.errors = false;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        n.error = null;
      }
      _ref1 = this.codes;
      for (symbol in _ref1) {
        codeobj = _ref1[symbol];
        ok = true;
        _ref2 = this.codes;
        for (symbol2 in _ref2) {
          codeobj2 = _ref2[symbol2];
          if (symbol === symbol2) {
            continue;
          }
          if (codeobj2.code.indexOf(codeobj.code) === 0) {
            ok = false;
            this.errors = true;
            err = {
              start: 0,
              end: codeobj.code.length
            };
            if (codeobj2.error != null) {
              codeobj2.error.push(err);
            } else {
              codeobj2.error = [err];
            }
          }
        }
        if (!ok) {
          codeobj.error = [
            {
              start: 0,
              end: codeobj.code.length
            }
          ];
        }
      }
      return this.errors;
    };

    CodeListCollection.prototype.arrangeCodes = function(start_x, start_y) {
      var codeobj, symbol, y, _ref, _results;
      y = start_y;
      _ref = this.codes;
      _results = [];
      for (symbol in _ref) {
        codeobj = _ref[symbol];
        codeobj.x = start_x;
        codeobj.y = y;
        _results.push(y += node_text_spacing);
      }
      return _results;
    };

    CodeListCollection.prototype.mousemove = function(pos) {
      var dx, dy, n, s, _i, _len, _ref, _ref1, _results;
      if ((this.selected != null) && (_ref = this.selected.node, __indexOf.call(this.nodes, _ref) >= 0)) {
        s = this.selected;
        dx = pos.x - s.mx + s.ox - s.node.x;
        dy = pos.y - s.my + s.oy - s.node.y;
        _ref1 = this.nodes;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          n = _ref1[_i];
          n.x += dx;
          _results.push(n.y += dy);
        }
        return _results;
      } else {
        return CodeListCollection.__super__.mousemove.call(this, pos);
      }
    };

    CodeListCollection.prototype.convertToTree = function() {
      var c, childstr, ci, codeobj, curnode, i, root, symbol, _i, _ref, _ref1;
      if (this.checkForErrors()) {
        throw 'not going to convert with errors';
      }
      root = {};
      _ref = this.codes;
      for (symbol in _ref) {
        codeobj = _ref[symbol];
        c = codeobj.code;
        curnode = root;
        for (i = _i = 0, _ref1 = c.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          ci = c[i];
          if (ci === '0') {
            childstr = 'child0';
          } else if (ci === '1') {
            childstr = 'child1';
          } else {
            throw 'bad character ' + ci;
          }
          if (curnode[childstr] != null) {
            curnode = curnode[childstr];
          } else {
            curnode = curnode[childstr] = {};
          }
        }
        curnode.leaf = symbol;
      }
      return construct_queue.push({
        "const": NodeCollectionFromCode,
        add_from: root
      });
    };

    return CodeListCollection;

  })(NodeCollection);

  NodeCollectionFromCode = (function(_super) {
    __extends(NodeCollectionFromCode, _super);

    function NodeCollectionFromCode(shape) {
      NodeCollectionFromCode.__super__.constructor.call(this, shape);
    }

    NodeCollectionFromCode.prototype.setNodes = function(tree, pos) {
      var rebuildFromTree;
      rebuildFromTree = (function(_this) {
        return function(node) {
          var newchild0, newchild1, newnode;
          if (node.leaf != null) {
            newnode = new Leaf('', node.leaf, _this.shape);
          } else {
            if (node.child0 != null) {
              newchild0 = rebuildFromTree(node.child0);
            } else {
              newchild0 = null;
            }
            if (node.child1 != null) {
              newchild1 = rebuildFromTree(node.child1);
            } else {
              newchild1 = null;
            }
            newnode = new Inner('', newchild0, newchild1, _this.shape);
          }
          newnode.x = pos.x;
          newnode.y = pos.y;
          return newnode;
        };
      })(this);
      this.nodes = [rebuildFromTree(tree)];
      this.tidy(this.nodes[0], pos);
    };

    return NodeCollectionFromCode;

  })(NodeCollection);

  lerp2d = function(t, p0, p1) {
    if (t < 0) {
      t = 0;
    }
    if (t > 1) {
      t = 1;
    }
    return {
      x: (p1.x - p0.x) * t + p0.x,
      y: (p1.y - p0.y) * t + p0.y
    };
  };

  NodeAnimation = (function() {
    function NodeAnimation(node, destpos, duration) {
      this.node = node;
      this.destpos = destpos;
      this.duration = duration;
      this.origpos = null;
    }

    NodeAnimation.prototype.setPosition = function(time) {
      var pos;
      if (this.origpos === null) {
        this.origpos = {
          x: this.node.x,
          y: this.node.y
        };
      }
      pos = lerp2d(time / this.duration, this.origpos, this.destpos);
      return this.node.move(pos.x, pos.y);
    };

    NodeAnimation.prototype.isFinished = function(time) {
      return time >= this.duration;
    };

    return NodeAnimation;

  })();

  CollectionAnimation = (function() {
    function CollectionAnimation(node_animations, start_time) {
      this.node_animations = node_animations;
      this.start_time = start_time;
    }

    CollectionAnimation.prototype.setPositions = function(time) {
      var a, _i, _len, _ref, _results;
      if (this.start_time === -1) {
        this.start_time = time;
      }
      _ref = this.node_animations;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        _results.push(a.setPosition(time - this.start_time));
      }
      return _results;
    };

    CollectionAnimation.prototype.isFinished = function(time) {
      var a, _i, _len, _ref;
      _ref = this.node_animations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        if (!a.isFinished(time - this.start_time)) {
          return false;
        }
      }
      return true;
    };

    return CollectionAnimation;

  })();

  canvas = document.getElementById('cnv');

  context = canvas.getContext('2d');

  render = function() {
    var collection, idx, t, _i, _j, _len, _len1;
    t = Date.now() / 1000;
    context.fillStyle = 'black';
    context.fillRect(0, 0, canvas.width, canvas.height);
    if (pendingString.length > 0) {
      context.fillStyle = 'white';
      context.font = '32px monospace';
      context.fillText(pendingString, 0, canvas.height - 32);
    }
    for (idx = _i = 0, _len = collections.length; _i < _len; idx = ++_i) {
      collection = collections[idx];
      collection.render(context, idx, t);
    }
    for (idx = _j = 0, _len1 = collections.length; _j < _len1; idx = ++_j) {
      collection = collections[idx];
      collection.render_overlay(context, idx, t);
    }
    return window.requestAnimationFrame(render);
  };

  window.requestAnimationFrame(render);

  document.addEventListener('keypress', function(e) {
    var s;
    if (e.ctrlKey || e.altKey || e.metaKey) {
      return true;
    } else {
      s = translateCharCode(e);
      if (s.length !== 0) {
        pendingString += s;
      }
      return e.preventDefault();
    }
  });

  document.addEventListener('keydown', function(e) {
    if (e.keyCode === 13) {
      engage(pendingString);
      pendingString = '';
      return e.preventDefault();
    } else if (e.keyCode === 8) {
      pendingString = pendingString.slice(0, -1);
      return e.preventDefault();
    }
  });

  canvas.addEventListener('mousedown', function(e) {
    var idx, pos, t, _i, _ref, _results;
    t = Date.now() / 1000;
    pos = getCursorPosition(canvas, e);
    _results = [];
    for (idx = _i = _ref = collections.length - 1; _i >= 0; idx = _i += -1) {
      if (collections[idx].mousedown(pos, idx, t)) {
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  });

  canvas.addEventListener('mousemove', function(e) {
    var collection, pos, _i, _len, _results;
    pos = getCursorPosition(canvas, e);
    _results = [];
    for (_i = 0, _len = collections.length; _i < _len; _i++) {
      collection = collections[_i];
      _results.push(collection.mousemove(pos));
    }
    return _results;
  });

  canvas.addEventListener('mouseup', function(e) {
    var c, collection, pos, t, _results;
    t = Date.now() / 1000;
    pos = getCursorPosition(canvas, e);
    collections = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = collections.length; _i < _len; _i++) {
        c = collections[_i];
        _results.push(c.mouseup(pos, t));
      }
      return _results;
    })();
    collections = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = collections.length; _i < _len; _i++) {
        c = collections[_i];
        if (c !== null) {
          _results.push(c);
        }
      }
      return _results;
    })();
    _results = [];
    while (construct_queue.length > 0) {
      c = construct_queue.shift();
      collection = new c["const"](shapes[next_shape]);
      next_shape = (next_shape + 1) % shapes.length;
      collection.setNodes(c.add_from, nextPos());
      _results.push(collections.push(collection));
    }
    return _results;
  });

}).call(this);

//# sourceMappingURL=tree2.map
